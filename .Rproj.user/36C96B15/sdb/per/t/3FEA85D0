{
    "collab_server" : "",
    "contents" : "###################################################################################\n############ Estimate genotype correlation matrix from reference panel ############\n###################################################################################\n\n#' Code additively the genotypes\n#' Sum the two columns per individual of the input matrix (each corresponding to one chromosome)\n#' to get the additive coding of the individual at the locus.\n#'\n#' @param genoMat is the matrix of genotype with two colums per individual\n#' Rows are variants and columns are individuals\n#' @param lind is the list of individual in the genotype matrix\n#'\n#' @return The additively coded genotyped matrix\n#'\n#' @examples\n#' genoMat = matrix(rbinom(5*10,1,runif(10,0,1)),nrow=5,ncol=10)\n#' lind = c(\"ind1\",\"ind2\",\"ind3\",\"ind4\",\"ind5\")\n#' colnames(genoMat) = rep(lind,each=2)\n#' addCodedMat = getAdditivelyCodedMatrix(genoMat, lind)\n#'\n#'@export\n\ngetAdditivelyCodedMatrix = function(genoMat,lind) {\n  res = matrix(0,nrow = dim(genoMat)[1],ncol=length(lind))\n  getGeno = function(i,genoMat,lind,res) {\n    res[,i] = apply(genoMat[,grepl(lind[i], colnames(genoMat))],1,sum)\n  }\n  res = mapply(getGeno,1:length(lind),MoreArgs=list(genoMat=genoMat,lind=lind,res=res))\n  return(res)\n}\n\n#' Change the coding of the variant\n#' if the reference allele differs between the data and the reference panel\n#'\n#' If reference alleles differs, new coding = 2 - old_coding\n#' Otherwise, no change\n#'\n#' @param x is the matrix of additively coded genotypes\n#' Rows are variants and columns are individuals\n#' @param v is a vector of boolean indicating wether reference alleles differ or not\n#'\n#' @return The additively coded genotyped matrix with coded allele in the matrix\n#' corresponding to the reference allele in the reference panel\n#'\n#' @examples\n#' genoMat = matrix(rbinom(5*5,2,runif(5,0,1)),nrow=5,ncol=5)\n#' sameRefAllele = rbinom(5,1,0.7)\n#' newGenoMat = changeCoding(genoMat, sameRefAllele)\n#'\n#'@export\n\nchangeCoding = function(x,v) {\n  tt = x\n  for (i in 1:dim(x)[1]) {\n    if (!v[i]) {\n      tt[i,] = -tt[i,] + 2\n    }\n  }\n  return(tt)\n}\n\n#' Compute the genotype correlation matrix.\n#'\n#' From a set of variants identified by the pair (chromosome, position), extract the SNPs from a reference\n#' panel in the specified population.\n#'\n#' Currently, this is hard-coded to access 1000 Genomes phase3 data hosted by\n#' Brian Browning (author of BEAGLE):\n#'\n#' \\url{http://bochet.gcc.biostat.washington.edu/beagle/1000_Genomes_phase3_v5a/}\n#'\n#' This implementation discards multi-allelic markers that have a \",\" in the\n#' ALT column.\n#'\n#' Position must be given in GRCh37 genome build.\n#'\n#' The \\code{pop} can be any of: ACB, ASW, BEB, CDX, CEU, CHB, CHS, CLM, ESN,\n#' FIN, GBR, GIH, GWD, IBS, ITU, JPT, KHV, LWK, MSL, MXL, PEL, PJL, PUR, STU,\n#' TSI, YRI. It can also be any super-population: AFR, AMR, EAS, EUR, SAS.\n#'\n#' Then, code additively the genotype and modify the additively coded allele if reference alleles\n#' differ between data and reference panel\n#' and finally compute the correlation matrix.\n#'\n#' Physical position must in\n#'\n#' @param lchr is a vector with the chromosome number of the variants to extract\n#' @param lpos is a vector with the physical position of the variants to extract\n#' @param lrefall is a vector with the reference allele of the variant in the data.\n#' @param pop is the 1000 Genomes code of the population in which data must be extracted\n#'\n#' @return The genotype correlation matrix of the specified variants\n#'\n#' @examples\n#' chrom = c(8,4)\n#' phys_pos = c(11843758,951947)\n#' refall = c(\"A\",\"T\")\n#' cor_matrix = getGenoCorMatrix(lchr = chrom,lpos = phys_pos , lrefall = refall, pop = \"EUR\")\n#'\n#' @export\n\ngetGenoCorMatrix = function(lchr,lpos, lrefall, pop) {\n  if (length(lchr)>1) {\n    lpop = rep(pop,length(lchr))\n    referencedata = mapply(get_vcf,lchr,lpos,lpos,lpop)\n    genoMat = Reduce(\"rbind\", lapply(1:dim(referencedata)[2], function(i) referencedata[,i]$geno))\n    genoMap = Reduce(\"rbind\",lapply(1:dim(referencedata)[2], function(i) referencedata[,i]$meta))\n\n    # Set allele to \"t\" when read allele is \"TRUE\"\n    genoMap$REF = vapply(genoMap$REF, function(x) if (!(as.character(x) %in% c(\"A\",\"C\",\"G\"))) {return(\"t\")} else {return(x)},\"\")\n\n    #Keep only founders\n    lind = referencedata[,1]$ind\n    lind = referencedata[,1]$ind[which(lind$Paternal.ID == 0 & lind$Maternal.ID == 0),2]\n\n    testMat = getAdditivelyCodedMatrix(genoMat,lind)\n    testMat = changeCoding(testMat,tolower(as.character(lrefall)) == tolower(genoMap$REF))\n    colnames(testMat) = lind\n    return(cor(t(testMat)))\n  }\n  else {\n    return(1)\n  }\n}\n\n#' Perform singular Value Decomposition on the correlation matrix\n#'\n#' @param cormat is the correlation matrix\n#' @param k is the number of eigen vectors to keep. Default is the correlation matrix rank.\n#'\n#' @return A list with :\n#' \\describe{\n#'   \\item{eigval}{A vector of the top \\code{k} eigenvalues}\n#'   \\item{eigvev}{A matrix of the top \\code{k} eigen vectors}\n#' }\n#'\n#'\n#' @examples\n#' a = matrix(runif(10*10,1,5),nrow=10)\n#' matcor = cor(a)\n#' getMatCorSVD(matcor)\n#' getMatCorSVD(matcor, k = 4)\n#'\n#' @export\n\ngetMatCorSVD = function(cormat, k = qr(cormat)$rank) {\n  cormat.svd = svd(cormat)\n  l = list()\n  l$eigval = cormat.svd$d[1:k]\n  l$eigvec = cormat.svd$v[,1:k]\n  return(l)\n}\n",
    "created" : 1498751498035.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "195331596",
    "id" : "3FEA85D0",
    "lastKnownWriteTime" : 1499774803,
    "last_content_update" : 1499774803649,
    "path" : "~/Bureau/PACK_R/PACKAGE/VarExp/R/correlationMatrix.R",
    "project_path" : "R/correlationMatrix.R",
    "properties" : {
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}