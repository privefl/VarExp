{
    "collab_server" : "",
    "contents" : "#' This is data included in the package\n#'\n#' @name ind\n#' @docType data\n#' @author Kamil Slowikowski \\email{kslowikowski@fas.harvard.edu}\n#' @references \\url{https://github.com/slowkow/proxysnps/blob/master/data/ind.rda}\n#' @keywords data\nNULL\n\n#' Example of GWAS result input file\n#'\n#' @name GWAS\n#' @docType data\n#' @author Vincent Laville \\email{vincent.laville@pasteur.fr}\n#' @keywords data\n\"GWAS\"\n\n#' Example of cohort description input file\n#' @name COHORT\n#' @docType data\n#' @author Vincent Laville \\email{vincent.laville@pasteur.fr}\n#' @keywords data\n\"COHORT\"\n\n#' Check that the table contains the mandatory columns\n#' and keep only rows (cohorts) with the specified ancestry \\code{pop}.\n#' If \\code{pop==\"ALL\"}, all rows are kept.\n#'\n#' @param df is the loaded data frame with individual cohorts information\n#' @param ancest is the ancestry analyzed\n#' @param pheno is the studied phenotype\n#' @param expo is the studied exposure\n#'\n#' @return The data frame with only rows corresponding to the studied population \\code{ancest}\n#' and colums corresponding to the studied phenotype \\code{pheno} and exposure \\code{expo}\n#'\n#' @examples\n#' data(\"COHORT\", package=\"VarExp\", envir = environment())\n#' df = preparePhenoTable(COHORT, \"EUR\", \"pheno1\", \"expo1\")\n#'\n#' @export\n\npreparePhenoTable = function(df,ancest,pheno,expo) {\n  colsToSearch = c(\"Cohort\",\"ANCESTRY\",paste0(pheno,\"_N\"),paste0(pheno,\"_Mean\"),paste0(pheno,\"_SD\"))\n\n  for (i in 1:length(colsToSearch)) {\n    if(!any(grepl(colsToSearch[i],colnames(df)))) {\n      stop(paste0(\"Missing column \\'\", colsToSearch[i], \"\\' in the cohort dataframe\"), call. = F)\n    }\n  }\n\n  if (ancest != \"ALL\") {\n    df = df[df$ANCESTRY == ancest, grepl(paste(\"Cohort|ANCESTRY\",paste0(pheno,\"_N\"),paste0(pheno,\"_Mean\"),paste0(pheno,\"_SD\"),paste(pheno,expo,sep=\"_\"),paste0(expo,\"_Mean\"), paste0(expo,\"_SD\"),sep=\"|\"),colnames(df))]\n    if (dim(df)[1] == 0) {\n      stop(paste0(\"Cannot find ancestry \", ancest, \" in the cohort dataframe\"), call. = F)\n    }\n  }\n  if (ancest == \"ALL\") {\n    df = df[, grepl(paste(\"Cohort|ANCESTRY\",paste0(pheno,\"_N\"),paste0(pheno,\"_Mean\"),paste0(pheno,\"_SD\"),paste(pheno,expo,sep=\"_\"),sep=\"|\"), colnames(df))]\n  }\n  df = na.omit(df)\n  return(df)\n}\n\n#' Check that the table contains the mandatory columns\n#' and keep only rows (cohorts) with the specified ancestry \\code{pop},\n#' the specified phenoype \\code{pheno}\n#' and the specified exposure \\code{expo}\n#'\n#' @param df is the loaded data frame with individual cohorts information\n#' @param ancest is the ancestry analyzed\n#' @param pheno is the studied phenotype\n#' @param expo is the studied exposure\n#'\n#' @return The data frame with only rows corresponding to the studied population \\code{ancest}\n#' and to the studied phenotype \\code{pheno} and exposure \\code{expo}\n#'\n#' @examples\n#' data(\"GWAS\", package=\"VarExp\", envir = environment())\n#' df = prepareResultTable(GWAS, \"EUR\", \"pheno1\", \"expo1\")\n#'\n#' @export\n\nprepareResultTable = function(df, ancest, pheno, expo) {\n  df = df[df$POP == ancest,]\n  if (dim(df)[1] == 0) {\n    stop(paste0(\"Cannot find ancestry \", ancest, \" in in the results dataframe\"), call. = F)\n  }\n  df = df[df$PHENO == pheno & df$EXPO == expo,]\n  if (dim(df)[1] == 0) {\n    stop(paste0(\"Cannot find phenotype - exposure \", paste(pheno,\" \", expo,sep = \"\"), \" in the results dataframe\"), call. = F)\n  }\n  return(df)\n}\n\n#' Calculate the mean and variance of a quantitative variable in a pooled sample of several cohorts\n#'\n#' @param N is a vector of sample size in each cohorts\n#' @param m is a vector of the mean of the variable in each individual cohort\n#' @param v is a vector of the standard deviation of the variable in each individual cohorts\n#'\n#' @return A vector of length 2 which first element is the mean and second element is the variance\n#'\n#'@examples\n#'sample_sizes = c(250, 1000, 10000,7500)\n#'means = c(2.5, 2.28, 2.32, 2.42)\n#'sds = c(1.05,1.1, 0.98, 0.94)\n#'parameters = calculateContParams(sample_sizes, means, sds)\n#'\n#'@export\n\ncalculateContParams = function(N,m,v) {\n  gmean = sum(N*m)/sum(N)\n  aa = (N-1) * v^2\n  bb = N * (m - gmean)^2\n  return(c(gmean,sum(aa+bb)/(sum(N) - 1)))\n}\n\n#' Calculate the mean and the variance of the exposure\n#'\n#' @param df is the dataframe with the cohort information\n#' @param pheno is the studied outcome\n#' @param expo is the studied exposure\n#'\n#' @return A vector of length 2 which first element is the mean and second element is the variance\n#'\n#' @examples\n#' #Case where E is quantitative\n#' datafr = data.frame(floor(rnorm(5,5000,2000)), runif(5,2.5,3), runif(5, 1.2, 1.4))\n#' colnames(datafr) = c(\"pheno_N\", \"pheno_expo_Mean\", \"pheno_expo_SD\")\n#' params = calculateExpoParams(df = datafr, pheno = \"pheno\", expo = \"expo\")\n#' #Case where E is binary\n#' datafr = data.frame(floor(rnorm(5,5000,2000)), floor(runif(5,1000,3000)))\n#' colnames(datafr) = c(\"pheno_N\", \"pheno_expo_P\")\n#' params = calculateExpoParams(df = datafr, pheno = \"pheno\", expo = \"expo\")\n#'\n#' @export\n\ncalculateExpoParams = function(df, pheno, expo) {\n    if (any(grepl(paste0(pheno, \"_\", expo,\"_P\"),colnames(df)))) {\n    n = df[,grepl(\"_N\",colnames(df))]\n    nexp = df[,grepl(paste0(expo,\"_P\"),colnames(df))]\n    meanval = sum(nexp)/sum(n)\n    return(c(meanval,meanval * (1-meanval)))\n  }\n  else if (any(grepl(paste0(pheno, \"_\", expo,\"_Mean\"), colnames(df))) & any(grepl(paste0(pheno, \"_\", expo,\"_SD\"),colnames(df)))) {\n    n = df[,grepl(\"_N\",colnames(df))]\n    m = df[,grepl(paste0(expo,\"_Mean\"),colnames(df))]\n    v = df[,grepl(paste0(expo,\"_SD\"),colnames(df))]\n    return(calculateContParams(n,m,v))\n  }\n  else {\n    stop(\"Cannot calcuate exposure parameters.\\nCheck columns names\")\n  }\n}\n\n#' Derive betas in the standardized model from betas in the general model\n#'\n#' @param betaG is the vector of main genetic effects in the general model\n#' @param betaINT is the vector of interaction effects in the general model\n#' @param maf is the vector of the variants' frequency\n#' @param meanE is the mean of the exposure\n#' @param varE is the variance of the exposure\n#' @param type designates the coefficients to standardize:\n#'  \"G\" for the main genetic effect and \"I\" for the interaction effects\n#'\n#' @return The vector of standardized effects\n#'\n#' @examples\n#' betaGs = rnorm(10, 0, 0.1)\n#' betaIs = rnorm(10, 0, 0.05)\n#' mafs = runif(10,0.05,0.95)\n#' meanE = runif(1,-2,2)\n#' varE = runif(1,0.5,1.5)\n#' std_betaG = standardizeBeta(betaGs, betaIs, mafs, meanE, varE, \"G\")\n#' std_betaI = standardizeBeta(betaGs, betaIs, mafs, meanE, varE, \"I\")\n#'\n#' \\dontrun{\n#' std_betaI = standardizeBeta(betaGs, betaIs, mafs, meanE, varE, \"anything different from G or I\")\n#' }\n#'\n#' @export\n\nstandardizeBeta = function(betaG,betaINT,maf,meanE,varE,type) {\n  if (type == \"I\") {\n    return(betaINT*sqrt(2 * maf * (1 - maf)) * sqrt(varE))\n  }\n  else if (type == \"G\") {\n    return((betaG + betaINT * meanE)*sqrt(2 * maf * (1 - maf)))\n  }\n  else {\n    stop(\"type must be either \\\"I\\\" or \\\"G\\\"\", call. = F)\n  }\n}\n\n#' Calculate the fraction of phenotypic variance explained by as set of significant\n#' genetic effect and/or interaction effects.\n#'\n#' This version does not take into account potential biases in\n#' neither the estimation of effect sizes nor the estimation of the correlation matrix\n#'\n#' @param std_bG is the vector of standardized genetic effect sizes\n#' @param std_bI is the vector of standardized interaction effect sizes\n#' @param matcor is the genotype correlation matrix\n#' @param varY is the phenotypic variance in the pooled sample\n#' @param type indicates wether only genetic or interactions effects should be considered\n#'  or if both should be considered jointly.\n#'\n#'  @return The fraction of phenotypic variance explained by user-specified effects.\n#'\n#'  @examples\n#'  std_bG = rnorm(5,0,0.01)\n#'  std_bI = rnorm(5,0,0.001)\n#'  matcor = cor(matrix(runif(5*5,1,5),nrow=5))\n#'  varY = 2.25\n#'  calculateVarFrac(std_bG, std_bI, matcor, varY, \"G\")\n#'  calculateVarFrac(std_bG, std_bI, matcor, varY, \"I\")\n#'  calculateVarFrac(std_bG, std_bI, matcor, varY, \"J\")\n#'\n#'  @importFrom MASS ginv\n#'  @export\n\ncalculateVarFrac = function(std_bG, std_bI,matcor,varY,type) {\n  if (type == \"G\") {\n    std_bI = rep(0, length(std_bG))\n  }\n  else if (type == \"I\") {\n    std_bG = rep(0, length(std_bI))\n  }\n  else if (type != \"J\") {\n    stop(\"type must be in c(\\\"G\\\", \\\"I\\\", \\\"J\\\"\", call. = F)\n  }\n  return((crossprod(t(crossprod(std_bG, ginv(matcor))), std_bG) + crossprod(t(crossprod(std_bI, ginv(matcor))), std_bI)) / varY)\n}\n\n#' Calculate the fraction of phenotypic variance explained by as set of significant\n#' genetic effect and/or interaction effects.\n#'\n#' This version takes into account potential rank deficiencies in the correlation matrix\n#' and noise in the  effect size estimation.\n#'\n#' For more details, see Shi et al., Am. J. Hum. Genet., 2016\n#'\n#' @param std_bG is the vector of standardized genetic effect sizes\n#' @param std_bI is the vector of standardized interaction effect sizes\n#' @param matcor is the genotype correlation matrix\n#' @param varY is the phenotypic variance in the pooled sample\n#' @param N is the total sample size\n#' @param type indicates wether only genetic or interactions effects should be considered\n#'  or if both should be considered jointly.\n#'\n#' @return The fraction of phenotypic variance explained by user-specified effects.\n#'\n#' @examples\n#' std_bG = rnorm(5,0,0.01)\n#' std_bI = rnorm(5,0,0.001)\n#' matcor = cor(matrix(runif(5*5,1,5),nrow=5))\n#' varY = 2.25\n#' N = 100000\n#' calculateVarFrac_v2(std_bG, std_bI, matcor, varY, N, \"G\")\n#' calculateVarFrac_v2(std_bG, std_bI, matcor, varY, N, \"I\")\n#' calculateVarFrac_v2(std_bG, std_bI, matcor, varY, N, \"J\")\n#'\n#' @importFrom MASS ginv\n#' @export\n\ncalculateVarFrac_v2 = function(std_bG, std_bI,matcor,varY, N,type) {\n  if (type == \"G\") {\n    std_bI = rep(0, length(std_bG))\n  }\n  else if (type == \"I\") {\n    std_bG = rep(0, length(std_bI))\n  }\n  else if (type != \"J\") {\n    stop(\"type must be in c(\\\"G\\\", \\\"I\\\", \\\"J\\\")\", call. = F)\n  }\n  q = qr(matcor)$rank\n  return((N * (crossprod(t(crossprod(std_bG, ginv(matcor))), std_bG) + crossprod(t(crossprod(std_bI, ginv(matcor))), std_bI)) - q) / ((N - q) * varY))\n}\n",
    "created" : 1498751465953.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "42|52|62|0|\n",
    "hash" : "33490991",
    "id" : "6FB4D60B",
    "lastKnownWriteTime" : 1502205749,
    "last_content_update" : 1502205749883,
    "path" : "~/Bureau/PACK_R/PACKAGE/VarExp/R/varFrac.R",
    "project_path" : "R/varFrac.R",
    "properties" : {
    },
    "relative_order" : 2,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}